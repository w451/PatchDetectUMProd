#pragma once
#include <windows.h>
#include <chrono>
#include <iostream>
#include "structas.h"

#define READ_PHYS CTL_CODE(0x8069, 0x869, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define QUERY_PFN_DB CTL_CODE(0x806a, 0x86a, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)
#define QUERY_VIRT_PAGE CTL_CODE(0x806b, 0x86b, METHOD_BUFFERED, FILE_READ_DATA | FILE_WRITE_DATA)

namespace Comm {

	//unsigned char driver_cipher[256] = { 0xba,0xd3,0x66,0xe8,0x61,0xca,0x9,0x8b,0x3e,0xb,0x17,0x40,0x2e,0x53,0x55,0x57,0x98,0xfb,0x1d,0x27,0x42,0x93,0x9d,0x22,0x1b,0xf5,0xdf,0xe0,0xff,0x8a,0x7b,0xd,0x91,0x72,0x4f,0x87,0xa9,0x1f,0x10,0x41,0xd7,0x2f,0x60,0xe5,0x9c,0x16,0x52,0x25,0xb6,0xb3,0x6e,0x84,0xe9,0xf6,0x34,0xce,0x2b,0x3c,0x3,0x39,0xe7,0x3b,0xa5,0x3a,0x86,0x8f,0xef,0x26,0x7c,0xd2,0xec,0x31,0x6c,0x8d,0x7d,0x44,0xc2,0xb5,0x62,0xb2,0xe3,0xdc,0x54,0xa,0xc8,0x21,0x83,0x43,0x28,0x12,0xe4,0x6a,0xbe,0x99,0x1,0x79,0xd6,0x92,0xb4,0xd1,0xc7,0xc5,0x4b,0xee,0xaf,0xf0,0x5f,0xc9,0xc4,0x20,0x77,0x4d,0x6d,0x38,0x23,0xd8,0xa4,0x73,0x95,0xcc,0x6b,0x5a,0x24,0xde,0xac,0x94,0x4a,0x36,0x19,0x7f,0xa1,0x2d,0x6,0x2a,0x6f,0x5,0x32,0x69,0xda,0x96,0xa6,0x8e,0x30,0xfc,0x9f,0x71,0x9b,0x64,0xd5,0x7,0xdb,0x37,0x89,0x4c,0xc3,0xa8,0xeb,0x65,0x5e,0x4e,0xbb,0x7e,0x47,0x56,0x68,0xf2,0xb0,0xd4,0x70,0x11,0x90,0x81,0x88,0x74,0xe1,0x1c,0xbd,0x78,0xfe,0x63,0x33,0xc6,0x75,0x1e,0x2c,0x49,0xa0,0xc0,0xe,0x8,0x48,0x97,0xc,0xdd,0xf4,0xed,0x5d,0xe6,0xa2,0x2,0x80,0x46,0x58,0xcd,0x67,0x9e,0x1a,0x3d,0xb9,0x8c,0xd9,0x5c,0xf8,0xb7,0xf9,0xbf,0x35,0x4,0xb1,0xcb,0x13,0x29,0xf1,0xad,0xcf,0x51,0x14,0x76,0xaa,0x3f,0xf3,0xab,0x82,0xa7,0xfa,0xea,0xf,0xa3,0xe2,0xd0,0xbc,0xb8,0x50,0x85,0x0,0x59,0x5b,0x7a,0x15,0xc1,0x18,0xfd,0xf7,0xae,0x9a,0x45 };
	unsigned char client_cipher[256] = { 0xf4,0x5e,0xc7,0x3a,0xd9,0x87,0x84,0x95,0xbd,0x6,0x53,0x9,0xc0,0x1f,0xbc,0xec,0x26,0xa9,0x59,0xdc,0xe2,0xf8,0x2d,0xa,0xfa,0x80,0xce,0x18,0xaf,0x12,0xb7,0x25,0x6d,0x55,0x17,0x72,0x7a,0x2f,0x43,0x13,0x58,0xdd,0x85,0x38,0xb8,0x83,0xc,0x29,0x8e,0x47,0x88,0xb4,0x36,0xd8,0x7f,0x97,0x71,0x3b,0x3f,0x3d,0x39,0xcf,0x8,0xe5,0xb,0x27,0x14,0x57,0x4b,0xff,0xc9,0xa2,0xbe,0xb9,0x7e,0x66,0x99,0x6f,0x9f,0x22,0xf2,0xe1,0x2e,0xd,0x52,0xe,0xa3,0xf,0xca,0xf5,0x79,0xf6,0xd3,0xc4,0x9e,0x6a,0x2a,0x4,0x4e,0xb3,0x93,0x9d,0x2,0xcc,0xa4,0x89,0x5b,0x78,0x48,0x70,0x32,0x86,0xa8,0x91,0x21,0x75,0xad,0xb6,0xe3,0x6e,0xb1,0x5f,0xf7,0x1e,0x44,0x4a,0xa1,0x81,0xc8,0xab,0xe8,0x56,0x33,0xf3,0x40,0x23,0xac,0x98,0x1d,0x7,0xd1,0x49,0x8d,0x41,0xaa,0x20,0x61,0x15,0x7d,0x76,0x8b,0xbf,0x10,0x5d,0xfe,0x92,0x2c,0x16,0xcd,0x90,0xba,0x82,0xc6,0xed,0x74,0x3e,0x8c,0xe9,0x9b,0x24,0xe4,0xe7,0x7c,0xdf,0xfd,0x68,0xa6,0xda,0x4f,0x31,0x62,0x4d,0x30,0xd5,0xf1,0xd0,0x0,0xa0,0xf0,0xb0,0x5c,0xd7,0xbb,0xf9,0x4c,0x9a,0x6c,0x65,0xb5,0x64,0x54,0x6b,0x5,0xdb,0x77,0xcb,0x37,0xe0,0xef,0x63,0x45,0x1,0xa7,0x94,0x60,0x28,0x73,0xd2,0x8a,0x96,0x51,0xc1,0x7b,0x1a,0x1b,0xae,0xee,0x50,0x5a,0x2b,0xc5,0x3c,0x3,0x34,0xeb,0x9c,0x46,0xc3,0x67,0x42,0x69,0xde,0xa5,0xe6,0xc2,0x19,0x35,0xfc,0xd4,0xd6,0xea,0x11,0x8f,0xfb,0xb2,0x1c };

	__forceinline void __fastcall substituteCipher(unsigned char* data, ULONG64 len) {
		for (ULONG64 i = 0; i < len; i++) {
			data[i] = client_cipher[data[i]];
		}
	}

	__forceinline bool __fastcall intermediateControl(HANDLE handle, DWORD cc, PVOID in, ULONG64 insize, PVOID out, ULONG64 outsize) {
		DWORD dataRead = 0;
		PVOID in_temp = malloc(insize+8);
		*(ULONG64*)in_temp = 0xab6eea1a379cec1a;
		memcpy((PVOID)(((ULONG64)in_temp)+8), in, insize);
		substituteCipher(((unsigned char*)in_temp)+8, insize);

		PVOID out_temp = malloc(outsize);
		memcpy(out_temp, out, outsize);
		
		bool result = DeviceIoControl(handle, cc, in_temp, insize + 8, out_temp, outsize, &dataRead, NULL);

		substituteCipher((unsigned char*)out_temp, dataRead);
		memcpy(out, out_temp, dataRead);

		free(in_temp);
		free(out_temp);

		return result;
	}

	HANDLE openDriver() {
		return CreateFileW(L"\\\\.\\PatchDetector", FILE_ALL_ACCESS, FILE_SHARE_READ | FILE_SHARE_WRITE, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	}

	bool readPhysMem(HANDLE handle, ULONG64 physAddress, BYTE* out, ULONG64 size) {
		return intermediateControl(handle, READ_PHYS, &physAddress, sizeof(physAddress), out, size);
	}

	bool queryPfnDatabase(HANDLE handle, ULONG64 pfn, PMMPFN out) {
		return intermediateControl(handle, QUERY_PFN_DB, &pfn, sizeof(ULONG64), out, sizeof(MMPFN));
	}

	bool queryVirtualPage(HANDLE handle, ULONG64 pid, ULONG64 virtualAddress, PTE* pte) {
		ULONG64 data[2] = {pid, virtualAddress};
		return intermediateControl(handle, QUERY_VIRT_PAGE, &data, sizeof(data), pte, sizeof(PTE));
	}
}
